---
description: 
globs: mobile/**
alwaysApply: false
---
# Cursor Rules for /mobile Directory

These rules guide AI interactions with the `mobile` React Native application codebase within the UnisKit monorepo.

## 1. Project Structure

*   **Source Code:** Located in `mobile/src/`.
*   **Routing:** Handled by Expo Router, with route files primarily in `mobile/src/app/`.
*   **Features:** Self-contained feature modules reside in `mobile/src/features/` (e.g., `auth`, `settings`).
*   **Shared Code:** Reusable components, hooks, context, types, and utilities specific to the *mobile app* are in `mobile/src/shared/`.
*   **Monorepo Shared Code:** Truly platform-agnostic code (theme definitions, core types) is sourced from the **`@uniskit/shared`** package (located at `packages/shared`). Imports from this package should use the `@uniskit/shared` alias.
*   **Path Aliases:** TypeScript paths are configured; use `@/` to refer to `mobile/src/`.

## 2. Theme Implementation & Usage

*   **Shared Definitions:** Core theme objects (`lightTheme`, `darkTheme`), fundamental types (`Theme`, `ThemePreference`, `ThemeContextType`), and theme constants (`colors`, `spacing`, `gaps`, `paddings`, `borderRadii`, `typography`, `iconSizes`) are defined in the **`@uniskit/shared`** package. Import these values from the shared package.
*   **Theme Context:** Theme switching logic and state management reside in `mobile/src/shared/context/ThemeContext.tsx`.
*   **Accessing Theme:** Use the `useTheme` hook (`import { useTheme } from '@/shared/context/ThemeContext'`) to access the current theme object (`theme`), `isDark` boolean, `themePreference`, and `setThemePreference` function within components.
*   **Applying Theme:** Apply theme values consistently for styling.
    *   Use `theme.colors...` for colors.
    *   Use constants like `paddings`, `gaps`, `borderRadii` from `@uniskit/shared` for layout spacing.
    *   Use `theme.typography...` for text styles (potentially indirectly via Text components).
    *   Use `iconSizes` from `@uniskit/shared` for icon dimensions.
*   **Avoid Hardcoding:** Do not hardcode colors, spacing values, or font sizes that are defined within the theme structure.

## 3. Base Component Implementation & Usage

*   **Layout Primitives:**
    *   `BaseRow` (`@/shared/components/layout/rows/BaseRow.tsx`): Fundamental row component using `flexDirection: 'row'`, `alignItems: 'center'`, and accepting `gap`.
    *   `BaseColumn` (`@/shared/components/layout/columns/BaseColumn.tsx`): Fundamental column component accepting `gap`.
    *   These use `BaseLayoutComponentProps` from `@uniskit/shared`.
*   **Semantic Layout Components:**
    *   Prefer using `SmallRow`, `MediumRow`, `LargeRow`, `SmallColumn`, `MediumColumn`, `LargeColumn` (from `@/shared/components/layout`) where appropriate.
    *   These components wrap their respective `Base*` component and apply a default `gap` from the shared theme (`gaps.small`, `gaps.medium`, `gaps.large`).
    *   Use these to enforce consistent spacing defaults. Only use `BaseRow`/`BaseColumn` directly if a specific non-standard gap (or no gap) is required, or override the `gap` prop on the semantic components.
*   **Views:**
    *   `BgView`: Use for main screen backgrounds, automatically applies `theme.colors.layout.background`.
    *   `FgView`: Use for foreground elements (like cards), automatically applies `theme.colors.layout.foreground`.
    *   `PageView`: Provides a standard scrollable page structure with safe area handling.
*   **Text Components:** Use the standard Text components (`TextBody`, `TextHeader`, `TextCaption`, `TextLink`, etc. from `@/shared/components/text`) which should internally reference theme typography and colors.
*   **Button Components:** Use `PrimaryButton`, `SecondaryButton`, `ListButton`, etc. (from `@/shared/components/buttons`).

## 4. State Management & API

*   **Local State:** Use standard React hooks (`useState`, `useEffect`, `useCallback`, `useMemo`).
*   **Global State:** Use React Context API for shared state (`ThemeContext`, `AuthContext`).
*   **API Client (`apiClient`):**
    *   Located at `mobile/src/api/client.ts`.
    *   Provides methods for standard HTTP requests: `get<T>`, `post<T>`, `put<T>`, `delete<T>`.
    *   **Usage:** Pass the API endpoint path (e.g., `/auth/request-otp`) and optionally a data payload (for `post`/`put`) and `RequestInit` options (like `{ signal }` for cancellation).
    *   **Error Handling:** The `apiClient` handles basic network errors and converts non-OK HTTP responses into a thrown `ApiError` object (shape: `{ message: string, error_code: string, status_code: number }`). It also includes logic for automatic token refresh on 401 errors.
    *   **Direct Usage:** Only use `apiClient` directly within dedicated API endpoint functions defined in `mobile/src/api/endpoints/`. Do *not* use `apiClient` directly within UI components or general hooks.
*   **API Endpoint Functions:**
    *   Define asynchronous functions for specific API calls in `mobile/src/api/endpoints/` (e.g., `authApi.ts`).
    *   These functions should accept necessary parameters (like email, OTP, tokens) and an optional `{ signal }` object.
    *   They call the appropriate `apiClient` method (e.g., `apiClient.post<RequestOTPResponse>('/auth/request-otp', { email }, { signal })`).
    *   They return the `Promise<ApiResponse<T>>` received from `apiClient`.
*   **API Hook (`useApi`):**
    *   Located at `mobile/src/api/useApi.ts`.
    *   **Purpose:** Wraps an API endpoint function to manage its state (`data`, `loading`, `error`), handle automatic request cancellation, and provide callbacks.
    *   **Usage:**
        *   Import: `import { useApi } from '@/api/useApi'`.
        *   Instantiate: `const { execute, data, loading, error, reset } = useApi<ResponseType, [Arg1Type, Arg2Type, ...]>(apiEndpointFunction, options?);`
            *   `ResponseType`: The expected type of the data within the successful `ApiResponse.data`.
            *   `[Arg1Type, ...]`: A tuple representing the types of the arguments your `apiEndpointFunction` expects (excluding the final `{ signal }` object).
            *   `apiEndpointFunction`: The specific function imported from `api/endpoints/`.
            *   `options`: Optional configuration object (`onSuccess`, `onError`, `initialData`).
    *   **Executing:** Call the returned `execute` function with the required arguments: `execute(arg1, arg2)`. This returns a `Promise<ResponseType | null>`.
    *   **State:** Access the API call state via `data` (holds `ResponseType` on success, `null` otherwise), `loading` (boolean), and `error` (holds `ApiError` on failure, `null` otherwise).
    *   **Resetting:** Call `reset()` to clear `data`, `error`, and `loading` back to their initial states. This is crucial before re-fetching or when inputs change.
    *   **Cancellation:** The hook handles AbortController logic internally. Calling `execute` again automatically cancels the previous request.
    *   **UI Layer:** Use the `useApi` hook within components or feature-specific hooks (like `useOTPVerification`) to trigger API calls and react to their state changes in the UI.

*Example: Using `useApi` for requesting OTP:*

```typescript
// In a hook or component:
import { useApi } from '@/api/useApi';
import { requestOTP } from '@/api/endpoints/authApi';
import { RequestOTPResponse, OTPRequest } from '@/api/types/auth.types';

// ...

const {
  execute: executeRequestOTP,
  loading: requestOtpLoading,
  error: requestOtpError,
  reset: resetRequestOtp
} = useApi<RequestOTPResponse, [Omit<OTPRequest, 'signal'>]>(requestOTP);

const handleSendOtp = async (email: string) => {
  resetRequestOtp(); // Reset previous state before new request
  try {
    // Pass only the arguments defined in the tuple type
    await executeRequestOTP({ email });
    // Handle success (e.g., show message, start timer)
  } catch (err) {
    // Error state is already set in `requestOtpError` by useApi
    console.error("OTP Request failed:", requestOtpError);
    // Handle error display in UI using requestOtpError.message
  }
};

// In UI:
// Display loading indicator based on `requestOtpLoading`
// Display error message based on `requestOtpError?.message`
```

## 5. Navigation (Expo Router)

*   **Structure:** Routes are defined by the file structure in `mobile/src/app/`. Layout groups (`(auth)`, `(main)`, `(stack)`) define navigation stacks/tabs.
*   **Configuration:** Navigator options (headers, tabs, modals) are configured in `_layout.tsx` files within the `app` directory structure.
*   **Navigation Hook:** Use the `useRouter` hook from `expo-router` for navigation actions.
*   **Actions:** Use `router.push()` for adding to the stack, `router.replace()` for replacing the current screen (useful for auth flows or resetting state), and `router.back()` for going back.
*   **Not Found:** The `+not-found.tsx` screen handles unmatched routes. Navigating away should typically use `router.replace('/')` to reset the navigation state to the application root.

## 6. Coding Standards & TypeScript

*   **TypeScript:** Maintain strict TypeScript usage. Define interfaces or types for all props, state, API responses, and complex objects. Leverage types from `@uniskit/shared`.
*   **Imports:** Use configured path aliases (`@/` for `mobile/src/`) for internal imports. Use the package name (`@uniskit/shared`) for shared library imports. Keep imports organized.
*   **Readability:** Write clear, understandable code. Keep components focused on a single responsibility. Use meaningful variable and function names.
*   **Comments:** Add comments only for complex logic or non-obvious sections. Avoid redundant comments.

## 7. AI Interaction Guidance (Cursor)

*   **Shared Code Awareness:** Remember that core theme definitions and types exist in `@uniskit/shared`. When asked to modify these, target the files in `packages/shared/src`.
*   **Mobile Specifics:** Theme *usage* (context, `useTheme`), layout components (`MediumRow`, etc.), navigation, and features are specific to `mobile/src/`.
*   **Apply Changes:** When implementing features or fixes, apply changes directly using the available tools, respecting the established patterns and structure outlined above.
*   **Dependency Linking:** Be aware that changes in `@uniskit/shared` require the package manager (`pnpm install` or equivalent) to be run at the monorepo root to be reflected in the `mobile` app.